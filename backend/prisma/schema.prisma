generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           Int      @id @default(autoincrement())
  email        String   @unique
  password     String
  role         String
  createdAt    DateTime @default(now())
  especialidad String?
  nombre       String
  activo       Boolean  @default(true)

  turnosCliente         Turno[]                @relation("TurnosCliente")
  turnosEmpleado        Turno[]                @relation("TurnosEmpleado")
  estadisticasTesoreria EstadisticaTesoreria[]
}

model Servicio {
  id           Int     @id @default(autoincrement())
  nombre       String
  descripcion  String
  precio       Float
  duracion     Int
  especialidad String
  turnos       Turno[]
}

model Producto {
  id             Int             @id @default(autoincrement())
  nombre         String
  descripcion    String
  precio         Float
  stock          Int
  stockPendiente Int             @default(0)
  marca          String?
  costoCompra    Float?
  proveedorId    Int?
  proveedor      Proveedor?      @relation(fields: [proveedorId], references: [id])
  turnoProductos TurnoProducto[]
  detallesCompra DetalleCompra[]
}

model Turno {
  id            Int                   @id @default(autoincrement())
  fechaHora     DateTime
  estado        String
  clienteId     Int?
  empleadoId    Int?
  servicioId    Int?
  createdAt     DateTime              @default(now())
  cliente       User?                 @relation("TurnosCliente", fields: [clienteId], references: [id])
  empleado      User?                 @relation("TurnosEmpleado", fields: [empleadoId], references: [id])
  servicio      Servicio?             @relation(fields: [servicioId], references: [id])
  productos     TurnoProducto[]
  estadisticas  EstadisticaTesoreria[]

  pago          Pago?                 @relation("PagoTurno")
}

model TurnoProducto {
  id         Int      @id @default(autoincrement())
  turnoId    Int
  productoId Int
  cantidad   Int
  turno      Turno    @relation(fields: [turnoId], references: [id])
  producto   Producto @relation(fields: [productoId], references: [id])
}

model EstadisticaTesoreria {
  id               Int      @id @default(autoincrement())
  turnoId          Int?
  empleadoId       Int?
  especialidad     String?
  ingresoServicio  Float
  ingresoProductos Float
  total            Float
  fecha            DateTime @default(now())

  productosVendidos Json?

  turno     Turno? @relation(fields: [turnoId], references: [id])
  empleado  User?  @relation(fields: [empleadoId], references: [id])

  @@index([turnoId])
}

model Proveedor {
  id        Int        @id @default(autoincrement())
  nombre    String
  telefono  String?
  email     String?
  direccion String?
  notas     String?
  productos Producto[]
  compras   Compra[]
  pagos     Pago[]     @relation("PagoProveedor")
  existe Boolean       @default(true)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
}

model Compra {
  id          Int             @id @default(autoincrement())
  fecha       DateTime        @default(now())
  total       Float           @default(0)
  proveedorId Int
  proveedor   Proveedor       @relation(fields: [proveedorId], references: [id])
  detalles    DetalleCompra[]
  pago        Pago?           @relation("PagoCompra")
}

model DetalleCompra {
  id         Int      @id @default(autoincrement())
  compraId   Int
  productoId Int
  cantidad   Int
  subtotal   Float
  compra     Compra   @relation(fields: [compraId], references: [id])
  producto   Producto @relation(fields: [productoId], references: [id])
}

model Pago {
  id          Int           @id @default(autoincrement())
  fecha       DateTime      @default(now())
  metodo      String        @default("Efectivo") // Efectivo, Transferencia, etc.
  tipo        String        // "Ingreso" o "Egreso"
  montoTotal  Float
  descripcion String?
  turnoId     Int?          @unique // 1 pago por turno (opcional)
  compraId    Int?          @unique // 1 pago por compra (opcional)
  proveedorId Int?          // muchos pagos por proveedor
  turno       Turno?        @relation("PagoTurno", fields: [turnoId], references: [id])
  compra      Compra?       @relation("PagoCompra", fields: [compraId], references: [id])
  proveedor   Proveedor?    @relation("PagoProveedor", fields: [proveedorId], references: [id])
  detalles    DetallePago[]
}

model DetallePago {
  id       Int    @id @default(autoincrement())
  pagoId   Int
  concepto String
  monto    Float
  pago     Pago   @relation(fields: [pagoId], references: [id])
}

model EgresoFijo {
  id          Int      @id @default(autoincrement())
  categoria   String
  subcategoria String?
  nota        String?
  monto       Float
  mes         Int
  anio        Int
  creadoPor   String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// IMPORTANTE: si existía un índice único en la base sobre (categoria, mes, anio) para "EgresoFijo",
// el desarrollador debe ejecutar algo como:
//   DROP INDEX IF EXISTS "categoria_mes_anio";
// en PostgreSQL antes de usar múltiples subcategorías de Servicios en un mismo mes.
